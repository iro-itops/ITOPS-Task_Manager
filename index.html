<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>ðŸš¨ ITOPS Command Center ðŸš¨</title>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<style>
  :root{
    --bg:#f5f6f8; --card:#ffffff; --muted:#6b7280; --accent:#50636d; --accent-2:#638188;
  }
  body { background:var(--bg); font-family: Inter, "Segoe UI", Roboto, Arial; margin:0; color:#1f2937; padding:18px; }
  .wrap{ max-width:1100px; margin:0 auto; }
  header{ display:flex; align-items:center; gap:12px; padding:14px 18px; background:var(--card); border-radius:10px; box-shadow:0 4px 16px rgba(16,24,40,0.06); margin-bottom:14px; }
  header h1{ margin:0; font-size:1.15rem; color:#0f172a; }
  header .sub{ color:var(--muted); font-size:0.9rem; margin-left:8px; }

  /* tabs */
  .tabs{ display:flex; gap:8px; margin:14px 0; flex-wrap:wrap; }
  .tab-btn{ padding:8px 12px; border-radius:10px; background:#e6eef0; color:#0f172a; border:none; cursor:pointer; font-weight:600; }
  .tab-btn.active{ background:var(--accent); color:#fff; box-shadow:0 6px 18px rgba(80,99,109,0.12); transform:translateY(-1px); }

  .card{ background:var(--card); border-radius:10px; padding:14px; box-shadow:0 4px 16px rgba(16,24,40,0.04); margin-bottom:14px; }

  /* DAILY tasks list */
  .task-card{ display:flex; gap:12px; align-items:flex-start; padding:10px; border-radius:8px; background:#fafafa; border:1px solid #eef2f6; margin-bottom:8px; }
  .task-left{ flex:1; }
  .task-name{ font-weight:700; margin-bottom:4px; }
  .task-desc{ color:var(--muted); font-size:0.88rem; margin-bottom:4px; }
  .task-right{ width:260px; display:flex; flex-direction:column; gap:6px; align-items:flex-end; }

  select, textarea, input[type=text] { padding:8px; border-radius:8px; border:1px solid #e6eef0; font-size:14px; width:100%; box-sizing:border-box; background:#fff; }

  .controls{ display:flex; gap:8px; margin-top:10px; }
  .btn{ padding:8px 12px; border-radius:8px; border:none; cursor:pointer; color:#fff; background:var(--accent-2); font-weight:700; }
  .btn.alt{ background:#e6eef0; color:#0f172a; font-weight:600; }
  .btn.warn{ background:#b03e3e; box-shadow:0 6px 18px rgba(176,62,62,0.12); }

  /* Monitoring grid */
  .monitor-grid{ display:grid; grid-template-columns: repeat(auto-fit,minmax(320px,1fr)); gap:12px; margin-top:10px; }
  .monitor-card{ padding:12px; border-radius:10px; background:#fff; border:1px solid #eef2f6; }
  .member-list label{ display:inline-flex; align-items:center; gap:8px; margin:6px 8px 6px 0; font-weight:600; }

  .slots { margin-top:10px; display:flex; flex-direction:column; gap:8px; }
  .slot-row{ display:flex; gap:10px; align-items:center; justify-content:space-between; }
  .slot-time{ min-width:160px; font-weight:700; color:#0f172a; }

  .output-box{ background:#f8fafb; padding:12px; border-radius:8px; border:1px solid #e6eef0; font-family:monospace; white-space:pre-wrap; min-height:140px; }

  footer { margin-top:12px; color:var(--muted); font-size:0.9rem; text-align:right; }

  /* presence */
  .presence-row { display:flex; gap:12px; align-items:center; justify-content:space-between; margin-bottom:8px; }
  .presence-box { display:flex; gap:10px; align-items:center; flex-wrap:wrap; margin-bottom:10px; padding:8px 10px; border-radius:8px; background:#f3f4f6; }
  .presence-item { display:inline-flex; gap:8px; align-items:center; padding:6px 8px; border-radius:6px; background:#fff; border:1px solid #eef2f6; font-weight:700; color:#0f172a; }
  .dot { width:10px; height:10px; border-radius:50%; background:#10b981; box-shadow:0 0 6px rgba(16,185,129,0.2); }

  /* modal */
  .modal-backdrop { position:fixed; inset:0; background:rgba(2,6,23,0.6); display:flex; align-items:center; justify-content:center; z-index:9999; }
  .modal { background:white; border-radius:10px; padding:18px; width:420px; max-width:94%; box-shadow:0 10px 40px rgba(2,6,23,0.4); }
  .modal h2 { margin:0 0 6px 0; font-size:1.05rem; }
  .modal p { margin:0 0 12px 0; color:var(--muted); }

  @media (max-width:680px){
    .task-right{ width:100%; align-items:stretch; }
    .slot-time{ min-width:0; }
  }
</style>
</head>
<body>
  <!-- TRIGRAM Modal (blocks until user enters trigram) -->
  <div id="trigramModal" class="modal-backdrop" style="display:none;">
    <div class="modal">
      <h2>Enter your TRIGRAM</h2>
      <p>Please enter your TRIGRAM (example: IRO, JMA, FFA). This identifies you in the Active users list.</p>
      <input id="trigramInput" type="text" placeholder="Enter TRIGRAM" style="width:100%; padding:10px; border-radius:8px; border:1px solid #e6eef0; font-weight:700; text-transform:uppercase;" maxlength="6" />
      <div style="display:flex; gap:8px; margin-top:12px; justify-content:flex-end;">
        <button id="trigramProceed" class="btn">Proceed</button>
      </div>
    </div>
  </div>

  <div class="wrap" id="app" style="opacity:0; pointer-events:none;">
    <header class="card" style="display:flex;align-items:center;">
      <div>
        <h1>ITOPS Command Center</h1>
        <div class="sub">Realtime â€” all users can edit. Today's data auto-saved to Firebase.</div>
      </div>
      <div style="margin-left:auto; display:flex; gap:8px; align-items:center;">
        <button id="resetBtn" class="btn warn">Reset Today's Data</button>
        <button id="resetTrigramBtn" class="btn alt" title="Clear stored trigram & presence">Reset Trigram</button>
      </div>
    </header>

    <div class="tabs">
      <button class="tab-btn active" data-tab="daily">Daily</button>
      <button class="tab-btn" data-tab="weekly">Weekly</button>
      <button class="tab-btn" data-tab="monthly">Monthly</button>
      <button class="tab-btn" data-tab="patching">Patching</button>
      <button class="tab-btn" data-tab="monitoring">Monitoring</button>
      <button class="tab-btn" data-tab="output">Output</button>
    </div>

    <!-- DAILY -->
    <section id="daily" class="card tab-pane active">
      <div class="presence-row">
        <div>
          <div style="font-weight:700; margin-bottom:6px;">Active users: <span id="activeCount">0</span></div>
          <div class="presence-box" id="presenceBox">
            <div style="color:var(--muted); font-weight:600;">Loading active users...</div>
          </div>
        </div>
        <div style="display:flex; gap:8px; align-items:center;">
          <button id="refreshPresence" class="btn alt">Refresh</button>
        </div>
      </div>

      <div style="display:flex;gap:12px;align-items:center;margin-bottom:12px;">
        <label style="font-weight:700;">Shift:</label>
        <select id="dailyShift">
          <option value="shift1">1st shift (06:30 - 14:30)</option>
          <option value="shift2">2nd shift (14:30 - 22:30)</option>
          <option value="shift3">3rd shift (22:30 - 06:30)</option>
        </select>
        <div style="margin-left:auto; display:flex; gap:8px; align-items:center;">
          <input id="addTaskInput" placeholder="Add new task name" style="padding:8px;border-radius:8px;border:1px solid #e6eef0;" />
          <button id="addTaskBtn" class="btn alt">Add Task</button>
        </div>
      </div>

      <div id="dailyTasks"></div>
    </section>

    <!-- WEEKLY -->
    <section id="weekly" class="card tab-pane" style="display:none;">
      <h3 style="margin:0 0 8px 0;">Weekly Tasks / Notes</h3>
      <textarea id="weeklyText" rows="6" placeholder="Type weekly tasks..."></textarea>
    </section>

    <!-- MONTHLY -->
    <section id="monthly" class="card tab-pane" style="display:none;">
      <h3 style="margin:0 0 8px 0;">Monthly Tasks / Notes</h3>
      <textarea id="monthlyText" rows="6" placeholder="Type monthly summary..."></textarea>
    </section>

    <!-- PATCHING -->
    <section id="patching" class="card tab-pane" style="display:none;">
      <h3 style="margin:0 0 8px 0;">Patching</h3>
      <textarea id="patchingText" rows="6" placeholder="Type patching tasks..."></textarea>
    </section>

    <!-- MONITORING -->
    <section id="monitoring" class="card tab-pane" style="display:none;">
      <h3 style="margin:0 0 10px 0;">Monitoring</h3>
      <div style="display:flex;gap:12px;align-items:center;">
        <label style="font-weight:700;">Shift:</label>
        <select id="monitorShift">
          <option value="shift1">1st shift (06:30 - 14:30)</option>
          <option value="shift2">2nd shift (14:30 - 22:30)</option>
          <option value="shift3">3rd shift (22:30 - 06:30)</option>
        </select>
        <div style="margin-left:auto; display:flex; gap:8px;">
          <button id="savePresentBtn" class="btn alt">Save Present Members</button>
          <button id="generateBtn" class="btn">Generate Slots</button>
          <button id="clearSlotsBtn" class="btn alt">Clear</button>
        </div>
      </div>

      <div class="monitor-grid" id="monitorGrid"></div>
    </section>

    <!-- OUTPUT -->
    <section id="output" class="card tab-pane" style="display:none;">
      <h3 style="margin:0 0 10px 0;">Generated Output (current shift)</h3>
      <div style="display:flex;gap:8px;align-items:center;">
        <button id="genOutputBtn" class="btn">Generate Output</button>
        <button id="copyBtn" class="btn alt">Copy</button>
        <button id="downloadBtn" class="btn alt">Download</button>
      </div>
      <div id="outputBox" class="output-box" style="margin-top:12px;"></div>
    </section>

    <footer>Prepared by Ian Romero - IT Operations</footer>
  </div>

  <!-- Firebase + logic -->
  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/12.3.0/firebase-app.js";
    import { getDatabase, ref, set, onValue, get, remove, onDisconnect } from "https://www.gstatic.com/firebasejs/12.3.0/firebase-database.js";

    // Firebase config (kept per request)
    const firebaseConfig = {
      apiKey: "AIzaSyC56asNTd04xhDU4OlnBHS4zNxj_aiiFhM",
      authDomain: "activity-log-275ce.firebaseapp.com",
      databaseURL: "https://activity-log-275ce-default-rtdb.asia-southeast1.firebasedatabase.app",
      projectId: "activity-log-275ce",
      storageBucket: "activity-log-275ce.firebasedestorage.app",
      messagingSenderId: "436390670385",
      appId: "1:436390670385:web:a4e4bf77c32d4061c76510"
    };

    const app = initializeApp(firebaseConfig);
    const db = getDatabase(app);

    // constants & defaults
    const TODAY = new Date().toISOString().slice(0,10); // YYYY-MM-DD
    const ROOT = '/ITOPS_Dashboard';
    const TASKS_PATH = `${ROOT}/dailyTasks/${TODAY}`; // per-date tasks (shift -> tasks object)
    const MON_PATH = `${ROOT}/monitoring/${TODAY}`;   // per-date monitoring (shift -> { membersPresent: {}, slots: {} })
    const FREETEXT_PATH = `${ROOT}/freetext/${TODAY}`;
    const PRESENCE_PATH = `${ROOT}/presence/${TODAY}`;

    const DEFAULT_MEMBERS = {
      shift1: ["IRO","FFA","JMA","NLA","MAG","RDE"],
	  //["PYC","CTR","CCR","LSU","HRO","DGU"] - swap nyo lang yung values sa loob ng current array
      shift2: ["DDI","CTR","HDE","MBA","ESO","AAS"],
	  //["IRO","JRU","JMA","NLA","MAG","RDE"] - swap nyo lang yung values sa loob ng current array
      shift3: ["PYC","JRU","CCR","LSU","HRO","DGU"]
	  //[DDI","FFA","HDE","MBA","ESO","AAS"] - swap nyo lang yung values sa loob ng current array
    };

    const DEFAULT_TASKS = {
      shift1: ["PW","ARC","Loglogic","TM1Top","ISMS","CRITICAL","PROXY","HO","Ticket Followup","TO"],
      shift2: ["PW","ARC","ISMS","Ticket Followup","TO"],
      shift3: ["PW","ARC","SC01 | SC02 Backup","SSRS Daily Report","Ticket Cleanup","Unknown Email Report","Ticket Followup","TO"]
    };

    const DESC_PLACEHOLDER = {
      PW: "PREWORK to be sent before starting the shift",
      ARC: "TM01 TM02 Arcsight checks",
      Loglogic: "LogLogic checks",
      TM1Top: "TM1Top monitoring",
      ISMS: "ISMS server report",
      CRITICAL: "Critical Serivces update",
      PROXY: "Proxy report checks",
      HO: "Handover email for SPOC",
      "Ticket Followup": "Follow up on open tickets - 1st shift = ASIA | 2nd shift = EMEA | 3rd shift = AMERICA ",
      TO: "Turnover / Reminders"
    };

    // UI refs
    const tabs = document.querySelectorAll('.tab-btn');
    const panes = document.querySelectorAll('.tab-pane');
    const dailyShift = document.getElementById('dailyShift');
    const dailyTasksEl = document.getElementById('dailyTasks');
    const addTaskInput = document.getElementById('addTaskInput');
    const addTaskBtn = document.getElementById('addTaskBtn');

    const weeklyText = document.getElementById('weeklyText');
    const monthlyText = document.getElementById('monthlyText');
    const patchingText = document.getElementById('patchingText');

    const monitorShift = document.getElementById('monitorShift');
    const monitorGrid = document.getElementById('monitorGrid');
    const generateBtn = document.getElementById('generateBtn');
    const savePresentBtn = document.getElementById('savePresentBtn');
    const clearSlotsBtn = document.getElementById('clearSlotsBtn');

    const genOutputBtn = document.getElementById('genOutputBtn');
    const outputBox = document.getElementById('outputBox');
    const copyBtn = document.getElementById('copyBtn');
    const downloadBtn = document.getElementById('downloadBtn');

    const resetBtn = document.getElementById('resetBtn');
    const resetTrigramBtn = document.getElementById('resetTrigramBtn');

    const presenceBox = document.getElementById('presenceBox');
    const activeCountEl = document.getElementById('activeCount');
    const refreshPresenceBtn = document.getElementById('refreshPresence');

    // Tab switching
    tabs.forEach(t => t.addEventListener('click', () => {
      tabs.forEach(b => b.classList.remove('active'));
      panes.forEach(p => p.style.display = 'none');
      t.classList.add('active');
      document.getElementById(t.dataset.tab).style.display = 'block';
    }));

    // Helpers
    const safeKey = s => String(s).replace(/[.#$\[\]\/]/g,'_');
    function formatTimeFromMinutes(mins) {
      const h = Math.floor(mins / 60) % 24;
      const m = mins % 60;
      const ampm = h >= 12 ? 'PM' : 'AM';
      const hh = h % 12 === 0 ? 12 : h % 12;
      return `${hh}:${String(m).padStart(2,'0')} ${ampm}`;
    }

    // TRIGRAM modal logic & presence session setup
    const trigramModal = document.getElementById('trigramModal');
    const trigramInput = document.getElementById('trigramInput');
    const trigramProceed = document.getElementById('trigramProceed');

    let trigram = localStorage.getItem("itopsTrigram");
    let sessionId = localStorage.getItem("itopsSessionId");
    let myPresenceRef = null;

    function showApp() {
      document.getElementById('app').style.opacity = '1';
      document.getElementById('app').style.pointerEvents = 'auto';
      trigramModal.style.display = 'none';
    }

    function showTrigramModal() {
      trigramModal.style.display = 'flex';
      trigramInput.focus();
    }

    function registerPresence(name) {
      // create/use session id to allow multiple sessions from same trigram
      sessionId = sessionId || ("sess-" + Math.random().toString(36).slice(2,9));
      localStorage.setItem("itopsSessionId", sessionId);
      myPresenceRef = ref(db, `${PRESENCE_PATH}/${sessionId}`);
      set(myPresenceRef, { name, ts: Date.now() }).catch(()=>{ /* ignore write errors */ });
      // ensure removal on disconnect
      try { onDisconnect(myPresenceRef).remove(); } catch(e){ /* no-op */ }
    }

    function clearLocalPresence() {
      // remove presence entry then remove stored trigram & sessionId
      if (myPresenceRef) {
        remove(myPresenceRef).catch(()=>{});
        myPresenceRef = null;
      }
      localStorage.removeItem("itopsTrigram");
      localStorage.removeItem("itopsSessionId");
    }

    // Trigram proceed button
    trigramProceed.addEventListener('click', () => {
      const v = (trigramInput.value || '').toUpperCase().trim();
      if (!v) return alert('Please enter your TRIGRAM');
      trigram = v;
      localStorage.setItem("itopsTrigram", trigram);
      registerPresence(trigram);
      showApp();
    });

    // Allow pressing enter key
    trigramInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') trigramProceed.click(); });

    // Reset trigram button
    resetTrigramBtn.addEventListener('click', () => {
      if (!confirm('Clear your stored trigram and remove your presence?')) return;
      clearLocalPresence();
      // reload to show modal again
      location.reload();
    });

    // If trigram already present, register presence immediately and hide modal
    (function handleTrigramOnLoad(){
      if (trigram) {
        // if session id not stored, create new one
        sessionId = sessionId || ("sess-" + Math.random().toString(36).slice(2,9));
        registerPresence(trigram);
        showApp();
      } else {
        // show modal
        showTrigramModal();
      }
    })();

    // PRESENCE UI render + realtime listening
    function renderPresence(snapshot) {
      presenceBox.innerHTML = '';
      const val = snapshot.exists() ? snapshot.val() : {};
      const entries = Object.entries(val || {});
      // Active users text shows the number of unique trigrams currently online (or sessions)
      // As requested, show one item per session (green dot)
      activeCountEl.textContent = entries.length;
      if (entries.length === 0) {
        const el = document.createElement('div');
        el.style.color = 'var(--muted)';
        el.style.fontWeight = '600';
        el.textContent = 'No active users';
        presenceBox.appendChild(el);
        return;
      }
      entries.forEach(([k,v])=>{
        const item = document.createElement('div');
        item.className = 'presence-item';
        item.innerHTML = `<span class="dot" aria-hidden></span><span>${v.name}</span>`;
        presenceBox.appendChild(item);
      });
    }

    // realtime presence listener
    onValue(ref(db, PRESENCE_PATH), (snap) => {
      renderPresence(snap);
    });

    // manual refresh presence (re-reads DB once)
    refreshPresenceBtn.addEventListener('click', async () => {
      const snap = await get(ref(db, PRESENCE_PATH));
      renderPresence(snap);
    });

    // Ensure defaults in DB (only set if missing)
    async function ensureDefaults() {
      // tasks skeleton per shift
      const tasksSnap = await get(ref(db, TASKS_PATH));
      if (!tasksSnap.exists()) {
        const payload = {};
        Object.entries(DEFAULT_TASKS).forEach(([shift, arr])=>{
          payload[shift] = { tasks: {} };
          arr.forEach(t => payload[shift].tasks[safeKey(t)] = "");
        });
        await set(ref(db, TASKS_PATH), payload);
      }
      // monitoring skeleton
      const msnap = await get(ref(db, MON_PATH));
      if (!msnap.exists()) {
        const base = {};
        ['shift1','shift2','shift3'].forEach(s => base[s] = { membersPresent: {}, slots: {} });
        await set(ref(db, MON_PATH), base);
      }
      // freetext skeleton
      const fSnap = await get(ref(db, FREETEXT_PATH));
      if (!fSnap.exists()) {
        await set(ref(db, FREETEXT_PATH), { weekly:"", monthly:"", patching:"" });
      }
    }

    // RENDER DAILY TASKS (cards aligned)
    function renderDailyTasks(shiftKey) {
      dailyTasksEl.innerHTML = "";
      // keep using DEFAULT_TASKS list for order / hard-coded descriptions
      const tasksList = DEFAULT_TASKS[shiftKey] || [];
      tasksList.forEach(taskName => {
        const row = document.createElement('div');
        row.className = 'task-card';
        const left = document.createElement('div'); left.className = 'task-left';
        const name = document.createElement('div'); name.className = 'task-name'; name.textContent = taskName;
        const desc = document.createElement('div'); desc.className = 'task-desc'; desc.textContent = DESC_PLACEHOLDER[taskName] || '';
        left.appendChild(name); left.appendChild(desc);

        const right = document.createElement('div'); right.className = 'task-right';
        const select = document.createElement('select');
        select.dataset.task = taskName;
        // placeholder -Select-
        select.innerHTML = `<option value="">-Select-</option>` + (DEFAULT_MEMBERS[shiftKey]||[]).map(m => `<option value="${m}">${m}</option>`).join('');
        right.appendChild(select);

        row.appendChild(left); row.appendChild(right);
        dailyTasksEl.appendChild(row);

        // realtime listener for this task's assignee
        const taskRef = ref(db, `${TASKS_PATH}/${shiftKey}/tasks/${safeKey(taskName)}`);
        onValue(taskRef, snap => {
          const v = snap.exists() ? snap.val() : "";
          if ((select.value || '') !== (v || '')) select.value = v || '';
        });

        // when user picks assignee -> save
        select.addEventListener('change', () => {
          const val = select.value || "";
          set(ref(db, `${TASKS_PATH}/${shiftKey}/tasks/${safeKey(taskName)}`), val);
        });
      });
    }

    // Add new task manually
    addTaskBtn.addEventListener('click', async () => {
      const name = (addTaskInput.value || '').trim();
      if (!name) return alert('Enter task name');
      const shiftKey = dailyShift.value || 'shift1';
      await set(ref(db, `${TASKS_PATH}/${shiftKey}/tasks/${safeKey(name)}`), "");
      if (!DEFAULT_TASKS[shiftKey].includes(name)) DEFAULT_TASKS[shiftKey].push(name);
      addTaskInput.value = '';
      renderDailyTasks(shiftKey);
    });

    // Keep UI in sync: re-render tasks on DB change
    onValue(ref(db, TASKS_PATH), snap => {
      const shiftKey = dailyShift.value || 'shift1';
      renderDailyTasks(shiftKey);
    });

    // When shift selection changes, render tasks for that shift
    dailyShift.addEventListener('change', () => {
      const sk = dailyShift.value;
      renderDailyTasks(sk);
    });

    // FREETEXT realtime bind
    function bindFreeText(key, el) {
      const r = ref(db, `${FREETEXT_PATH}/${key}`);
      onValue(r, snap => { const v = snap.exists() ? snap.val() : ""; if (el.value !== v) el.value = v; });
      el.addEventListener('input', () => set(ref(db, `${FREETEXT_PATH}/${key}`), el.value));
    }
    bindFreeText('weekly', weeklyText);
    bindFreeText('monthly', monthlyText);
    bindFreeText('patching', patchingText);

    // MONITORING: render members checkboxes and slots per shift
    function renderMonitoring() {
      monitorGrid.innerHTML = '';
      ['shift1','shift2','shift3'].forEach(shiftKey => {
        const card = document.createElement('div'); card.className = 'monitor-card';
        const title = document.createElement('div'); title.innerHTML = `<strong>${shiftKey.toUpperCase()}</strong>`;
        card.appendChild(title);

        const memberList = document.createElement('div'); memberList.className = 'member-list'; memberList.style.marginTop='8px';
        (DEFAULT_MEMBERS[shiftKey] || []).forEach(m => {
          const label = document.createElement('label');
          label.innerHTML = `<input type="checkbox" data-member="${m}" data-shift="${shiftKey}"/> ${m}`;
          memberList.appendChild(label);
        });
        card.appendChild(memberList);

        // place for slots
        const slotsWrap = document.createElement('div'); slotsWrap.className = 'slots'; slotsWrap.id = `slots-${shiftKey}`;
        card.appendChild(slotsWrap);
        monitorGrid.appendChild(card);

        // load present members from DB and check boxes
        const presentRef = ref(db, `${MON_PATH}/${shiftKey}/membersPresent`);
        onValue(presentRef, snap => {
          const present = snap.exists() ? snap.val() : {};
          memberList.querySelectorAll('input[type=checkbox]').forEach(cb => { cb.checked = !!present[cb.dataset.member]; });
        });

        // watch slots for this shift and render
        const slotsRef = ref(db, `${MON_PATH}/${shiftKey}/slots`);
        onValue(slotsRef, snap => {
          const slots = snap.exists() ? snap.val() : {};
          // get present members to populate options
          get(ref(db, `${MON_PATH}/${shiftKey}/membersPresent`)).then(msnap => {
            const presentObj = msnap.exists() ? msnap.val() : {};
            const presentMembers = Object.keys(presentObj || {});
            slotsWrap.innerHTML = '';
            const entries = Object.entries(slots || {});
            // sort by stored startMin if present for deterministic order
            entries.sort((a,b) => (a[1].startMin||0) - (b[1].startMin||0));
            if (entries.length === 0) {
              slotsWrap.innerHTML = '<div style="color:var(--muted);font-size:0.9rem;">No slots yet. Tick members and click Generate Slots.</div>';
            } else {
              entries.forEach(([slotKey, sData]) => {
                const row = document.createElement('div'); row.className='slot-row';
                const timeDiv = document.createElement('div'); timeDiv.className = 'slot-time'; timeDiv.textContent = sData.label || slotKey;
                const sel = document.createElement('select'); sel.dataset.slot = slotKey;
                sel.innerHTML = `<option value="">-Select-</option>` + presentMembers.map(m => `<option value="${m}">${m}</option>`).join('');
                sel.value = sData.member || '';
                sel.addEventListener('change', () => {
                  set(ref(db, `${MON_PATH}/${shiftKey}/slots/${slotKey}/member`), sel.value || '');
                });
                row.appendChild(timeDiv); row.appendChild(sel);
                slotsWrap.appendChild(row);
              });
            }
          });
        });
      });
    }

    // Save present members (persist checkboxes to DB for selected monitorShift)
    savePresentBtn.addEventListener('click', async () => {
      const shiftKey = monitorShift.value || 'shift1';
      const checked = Array.from(document.querySelectorAll(`input[type=checkbox][data-shift="${shiftKey}"]`)).filter(cb => cb.checked).map(cb => cb.dataset.member);
      const payload = {};
      checked.forEach(m => payload[m] = true);
      await set(ref(db, `${MON_PATH}/${shiftKey}/membersPresent`), payload);
      alert('Saved present members for ' + shiftKey);
    });

    // Generate slots: divides shift time evenly based on number of checked members for the selected monitorShift
    generateBtn.addEventListener('click', async () => {
      const shiftKey = monitorShift.value || 'shift1';
      const checkedMembers = Array.from(document.querySelectorAll(`input[type=checkbox][data-shift="${shiftKey}"]`)).filter(cb => cb.checked).map(cb => cb.dataset.member);
      if (checkedMembers.length === 0) { alert('Select at least one member for this shift (tick checkboxes)'); return; }
      // save membersPresent
      const mp = {}; checkedMembers.forEach(m => mp[m] = true);
      await set(ref(db, `${MON_PATH}/${shiftKey}/membersPresent`), mp);

      // determine shift minutes (exact)
      const shiftTimes = {
        shift1: {startMin: 6*60 + 30, endMin: 14*60 + 30}, // 06:30 - 14:30
        shift2: {startMin: 14*60 + 30, endMin: 22*60 + 30}, // 14:30 - 22:30
        shift3: {startMin: 22*60 + 30, endMin: (24*60) + (6*60 + 30)} // 22:30 - 06:30 (next day)
      };
      const st = shiftTimes[shiftKey].startMin;
      const en = shiftTimes[shiftKey].endMin;
      const totalMin = en - st;
      const perSlot = Math.floor(totalMin / checkedMembers.length);
      // create slot objects
      const slotsObj = {};
      let cur = st;
      for (let i=0;i<checkedMembers.length;i++){
        const sMin = cur;
        const eMin = (i===checkedMembers.length-1) ? en : (cur + perSlot);
        const label = `${formatTimeFromMinutes(sMin)} - ${formatTimeFromMinutes(eMin)}`;
        const key = safeKey(label);
        slotsObj[key] = { label, member: "", startMin: sMin, endMin: eMin };
        cur = eMin;
      }
      await set(ref(db, `${MON_PATH}/${shiftKey}/slots`), slotsObj);
      alert('Slots generated for ' + shiftKey);
    });

    // Clear slots for selected monitorShift
    clearSlotsBtn.addEventListener('click', async () => {
      const shiftKey = monitorShift.value || 'shift1';
      await set(ref(db, `${MON_PATH}/${shiftKey}`), { membersPresent: {}, slots: {} });
      alert('Cleared monitoring for ' + shiftKey);
    });

    // When monitorShift changed, re-render (UI shows all shifts but reactivity handled by onValue)
    monitorShift.addEventListener('change', () => {
      renderMonitoring();
    });

    // MONITOR GRID initial render & DB listeners
    renderMonitoring();

    // FREETEXT watchers (initial sync + input -> DB)
    onValue(ref(db, `${FREETEXT_PATH}/weekly`), snap => { weeklyText.value = snap.exists() ? snap.val() : ''; });
    onValue(ref(db, `${FREETEXT_PATH}/monthly`), snap => { monthlyText.value = snap.exists() ? snap.val() : ''; });
    onValue(ref(db, `${FREETEXT_PATH}/patching`), snap => { patchingText.value = snap.exists() ? snap.val() : ''; });

    weeklyText.addEventListener('input', () => set(ref(db, `${FREETEXT_PATH}/weekly`), weeklyText.value));
    monthlyText.addEventListener('input', () => set(ref(db, `${FREETEXT_PATH}/monthly`), monthlyText.value));
    patchingText.addEventListener('input', () => set(ref(db, `${FREETEXT_PATH}/patching`), patchingText.value));

    // OUTPUT generation: includes Daily, Weekly, Monthly, Patching, Monitoring for current selected dailyShift
    genOutputBtn.addEventListener('click', async () => {
      const shiftKey = dailyShift.value || 'shift1';
      const now = new Date();
      const generated = now.toLocaleString();

      // daily tasks
      const tasksSnap = await get(ref(db, `${TASKS_PATH}/${shiftKey}/tasks`));
      const tasks = tasksSnap.exists() ? tasksSnap.val() : {};

      const weeklySnap = await get(ref(db, `${FREETEXT_PATH}/weekly`));
      const monthlySnap = await get(ref(db, `${FREETEXT_PATH}/monthly`));
      const patchingSnap = await get(ref(db, `${FREETEXT_PATH}/patching`));

      const monSnap = await get(ref(db, `${MON_PATH}/${shiftKey}/slots`));
      const monitors = monSnap.exists() ? monSnap.val() : {};

      let out = `IT OPERATIONS TASKS REPORT - ${shiftKey.toUpperCase()}\nDate: ${TODAY}\nGenerated: ${generated}\n\n`;
      out += `--- DAILY TASKS ---\n`;
      (DEFAULT_TASKS[shiftKey] || []).forEach(t => {
        const val = tasks[safeKey(t)] || '';
        out += `${t} â€” ${val || 'Unassigned'}\n`;
      });

      out += `\n--- WEEKLY ---\n${weeklySnap.exists() ? weeklySnap.val() : ''}\n\n`;
      out += `--- MONTHLY ---\n${monthlySnap.exists() ? monthlySnap.val() : ''}\n\n`;
      out += `--- PATCHING ---\n${patchingSnap.exists() ? patchingSnap.val() : ''}\n\n`;

      out += `--- MONITORING (${shiftKey}) ---\n`;
      const sortedSlots = Object.entries(monitors || {}).sort((a,b) => (a[1].startMin||0) - (b[1].startMin||0));
      sortedSlots.forEach(([k,v]) => {
        out += `${v.label} â€” ${v.member || 'Unassigned'}\n`;
      });

      outputBox.textContent = out;
      // also store latest report in DB so others see it (optional)
      await set(ref(db, `${ROOT}/finalOutput/${TODAY}/${shiftKey}`), out);
    });

    // copy & download
    copyBtn.addEventListener('click', async () => {
      const text = outputBox.textContent || '';
      if (!text) return alert('Generate output first');
      await navigator.clipboard.writeText(text);
      alert('Copied to clipboard');
    });
    downloadBtn.addEventListener('click', () => {
      const text = outputBox.textContent || '';
      if (!text) return alert('Generate output first');
      const blob = new Blob([text], { type: 'text/plain' });
      const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = `itops-${TODAY}-${dailyShift.value||'shift'}.txt`; a.click();
    });

    // Reset today's data
    resetBtn.addEventListener('click', async () => {
      if (!confirm('Reset ALL data for today? This will clear daily tasks assignments, freetexts, and monitoring for today.')) return;
      await remove(ref(db, TASKS_PATH));
      await remove(ref(db, MON_PATH));
      await remove(ref(db, FREETEXT_PATH));
      // re-initialize defaults locally & UI
      await ensureDefaults();
      renderDailyTasks(dailyShift.value || 'shift1');
      renderMonitoring();
      outputBox.textContent = '';
      alert('Today data reset');
    });

    // Initial setup
    (async function init(){
      await ensureDefaults();
      renderDailyTasks(dailyShift.value || 'shift1');
      renderMonitoring();

      // ensure freetext UI gets DB values on load
      const w = await get(ref(db, `${FREETEXT_PATH}/weekly`)); if (w.exists()) weeklyText.value = w.val();
      const m = await get(ref(db, `${FREETEXT_PATH}/monthly`)); if (m.exists()) monthlyText.value = m.val();
      const p = await get(ref(db, `${FREETEXT_PATH}/patching`)); if (p.exists()) patchingText.value = p.val();
    })();

  </script>
</body>
</html>
